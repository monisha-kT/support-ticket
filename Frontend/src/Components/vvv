// import React, { useState, useEffect, useRef, useReducer, useCallback, useMemo } from 'react';
// import {
//   Box, TextField, IconButton, Paper, Typography, Avatar,
//   CircularProgress, Alert, IconButton as MuiIconButton
// } from '@mui/material';
// import SendIcon from '@mui/icons-material/Send';
// import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
// import useStore from '../store/useStore';
// import { getSocket } from './socket';
// import { useNavigate } from 'react-router-dom';
// import { debounce, throttle } from 'lodash';
// import { shallow } from 'zustand/shallow';

// // API URL configuration
// const API_URL = (() => {
//   try {
//     if (typeof process !== 'undefined' && process.env) {
//       return process.env.REACT_APP_API_URL || 'http://localhost:5000';
//     }
//     if (typeof import.meta !== 'undefined' && import.meta.env) {
//       return import.meta.env.VITE_API_URL || 'http://localhost:5000';
//     }
//     return 'http://localhost:5000';
//   } catch (e) {
//     console.warn('Error accessing environment variables:', e);
//     return 'http://localhost:5000';
//   }
// })();

// // Reducer for messages and ticketStatus
// const chatReducer = (state, action) => {
//   console.log('Reducer action:', action.type, action.payload, 'Current state:', state);
//   switch (action.type) {
//     case 'ADD_MESSAGE':
//       if (state.messages.some((msg) => msg.id === action.payload.id)) {
//         console.warn('Duplicate message ignored:', action.payload.id);
//         return state;
//       }
//       return { ...state, messages: [...state.messages, action.payload] };
//     case 'SET_MESSAGES':
//       const newMessages = action.payload.filter(
//         (msg) => !state.messages.some((existing) => existing.id === msg.id)
//       );
//       return { ...state, messages: [...state.messages, ...newMessages] };
//     case 'SET_TICKET_STATUS':
//       if (state.ticketStatus === action.payload) {
//         console.log('Ticket status unchanged, ignoring:', action.payload);
//         return state;
//       }
//       return { ...state, ticketStatus: action.payload };
//     default:
//       return state;
//   }
// };

// // Error Boundary Component
// class ErrorBoundary extends React.Component {
//   state = { hasError: false, error: null };

//   static getDerivedStateFromError(error) {
//     return { hasError: true, error };
//   }

//   componentDidCatch(error, errorInfo) {
//     console.error('Error caught in ErrorBoundary:', error, errorInfo);
//   }

//   render() {
//     if (this.state.hasError) {
//       return (
//         <Box sx={{ p: 2 }}>
//           <Alert severity="error">
//             Something went wrong: {this.state.error?.message || 'Unknown error'}
//           </Alert>
//         </Box>
//       );
//     }
//     return this.props.children;
//   }
// }

// const ChatWindow = ({ ticketId, readOnly = false, initialMessages = [], inactivityTimeout = 120000 }) => {
//   const [message, setMessage] = useState('');
//   const [isSending, setIsSending] = useState(false);
//   const [chatState, dispatch] = useReducer(chatReducer, {
//     messages: initialMessages,
//     ticketStatus: null
//   });
//   const [loading, setLoading] = useState(Boolean(ticketId && !initialMessages.length));
//   const [error, setError] = useState('');
//   const [showScrollButton, setShowScrollButton] = useState(false);
//   const messagesEndRef = useRef(null);
//   const scrollContainerRef = useRef(null);
//   const socketRef = useRef(null);
//   const inactivityTimerRef = useRef(null);
//   const lastSentMessageRef = useRef(null);
//   const reconnectAttemptsRef = useRef(0);
//   const lastTicketIdRef = useRef(ticketId);
//   const lastFetchTimeRef = useRef(0);
//   const navigate = useNavigate();

//   // Memoized user from Zustand store
//   const user = useMemo(() => useStore(
//     (state) => ({
//       id: state.user?.id,
//       firstName: state.user?.firstName,
//       lastName: state.user?.lastName
//     }),
//     shallow
//   ), []);

//   // Render counter and state logging
//   const renderCount = useRef(0);
//   useEffect(() => {
//     renderCount.current += 1;
//     console.log(`Render #${renderCount.current} for ChatWindow, ticketId: ${ticketId}`, {
//       loading,
//       error,
//       showScrollButton,
//       messageLength: message.length,
//       messageCount: chatState.messages.length,
//       ticketStatus: chatState.ticketStatus,
//       isSending
//     });
//     if (lastTicketIdRef.current !== ticketId) {
//       console.warn('Ticket ID changed:', { old: lastTicketIdRef.current, new: ticketId });
//       lastTicketIdRef.current = ticketId;
//     }
//   });

// //  Log prop changes
//   useEffect(() => {
//     console.log('Props changed:', { ticketId, readOnly, initialMessagesLength: initialMessages.length, inactivityTimeout });
//   }, [ticketId, readOnly, initialMessages, inactivityTimeout]);

//   // Clear error after 5 seconds
//   useEffect(() => {
//     if (error) {
//       const timer = setTimeout(() => setError(''), 5000);
//       return () => clearTimeout(timer);
//     }
//   }, [error]);

//   // Throttled dispatch
//   const throttledDispatch = useCallback(
//     throttle((action) => dispatch(action), 500),
//     []
//   );

//   // Fetch messages
//   const fetchMessages = useCallback(async () => {
//     if (!ticketId) return;
//     const token = localStorage.getItem('token');
//     if (!token) {
//       setError('Please log in to view messages.');
//       navigate('/');
//       return;
//     }
//     try {
//       setLoading(true);
//       const response = await fetch(`${API_URL}/api/chats/${ticketId}`, {
//         headers: { Authorization: `Bearer ${token}` }
//       });
//       if (!response.ok) {
//         throw new Error('Failed to fetch messages');
//       }
//       const data = await response.json();
//       throttledDispatch({ type: 'SET_MESSAGES', payload: data });
//     } catch (error) {
//       console.error('Fetch Messages Error:', error);
//       setError('Unable to load messages.');
//       if (error.message.includes('token') || error.message.includes('Unauthorized')) {
//         localStorage.removeItem('token');
//         localStorage.removeItem('user');
//         navigate('/');
//       }
//     } finally {
//       setLoading(false);
//     }
//   }, [ticketId, navigate, throttledDispatch]);

//   // Fetch ticket status
//   const fetchTicketStatus = useCallback(async () => {
//     if (!ticketId) return;
//     try {
//       const token = localStorage.getItem('token');
//       if (!token) {
//         throw new Error('No authentication token found');
//       }
//       const response = await fetch(`${API_URL}/api/tickets/${ticketId}`, {
//         headers: { Authorization: `Bearer ${token}` }
//       });
//       if (!response.ok) {
//         throw new Error('Failed to fetch ticket status');
//       }
//       const data = await response.json();
//       throttledDispatch({ type: 'SET_TICKET_STATUS', payload: data.status });
//     } catch (error) {
//       console.error('Error fetching ticket status:', error);
//       setError('Unable to load ticket status.');
//       if (error.message.includes('token') || error.message.includes('Unauthorized')) {
//         localStorage.removeItem('token');
//         localStorage.removeItem('user');
//         navigate('/');
//       }
//     }
//   }, [ticketId, navigate, throttledDispatch]);

//   // Initialize socket
//   const initializeSocket = useCallback(async () => {
//     if (readOnly || !ticketId || ticketId === 'null') {
//       setLoading(false);
//       return;
//     }
//     try {
//       setLoading(true);
//       const socketInstance = await getSocket();
//       if (!socketInstance) {
//         throw new Error('Socket initialization failed.');
//       }

//       socketRef.current = socketInstance;
//       socketInstance.emit('join', { ticket_id: ticketId });

//       socketInstance.on('connect', () => {
//         console.log('WebSocket connected for ticket:', ticketId);
//         setError('');
//         reconnectAttemptsRef.current = 0;
//       });

//       let pendingMessages = [];
//       socketInstance.on('message', (newMessage) => {
//         console.log('WebSocket message received:', newMessage);
//         if (newMessage.ticket_id === String(ticketId)) {
//           pendingMessages.push({
//             id: newMessage.id || crypto.randomUUID(),
//             message: newMessage.message,
//             sender_id: newMessage.sender_id,
//             sender_name: newMessage.sender_name || 'Unknown',
//             timestamp: newMessage.timestamp || new Date().toISOString(),
//             is_system: false
//           });
//           throttledDispatch({
//             type: 'SET_MESSAGES',
//             payload: pendingMessages
//           });
//           pendingMessages = [];
//         }
//       });

//       socketInstance.on('ticket_closed', ({ ticket_id, reason, reassigned_to, status }) => {
//         if (ticket_id !== String(ticketId)) return;
//         throttledDispatch({ type: 'SET_TICKET_STATUS', payload: status || 'closed' });
//         throttledDispatch({
//           type: 'ADD_MESSAGE',
//           payload: {
//             id: crypto.randomUUID(),
//             message: `Ticket ${status === 'assigned' ? 'reassigned' : 'closed'}. Reason: ${reason}${reassigned_to ? `. Reassigned to member ID ${reassigned_to}` : ''}`,
//             timestamp: new Date().toISOString(),
//             is_system: true
//           }
//         });
//       });

//       socketInstance.on('ticket_reopened', ({ ticket_id }) => {
//         if (ticket_id !== String(ticketId)) return;
//         throttledDispatch({ type: 'SET_TICKET_STATUS', payload: 'assigned' });
//         throttledDispatch({
//           type: 'ADD_MESSAGE',
//           payload: {
//             id: crypto.randomUUID(),
//             message: 'Ticket has been reopened',
//             timestamp: new Date().toISOString(),
//             is_system: true
//           }
//         });
//       });

//       socketInstance.on('ticket_inactive', ({ ticket_id, status, reason }) => {
//         if (ticket_id !== String(ticketId)) return;
//         throttledDispatch({ type: 'SET_TICKET_STATUS', payload: status || 'inactive' });
//         throttledDispatch({
//           type: 'ADD_MESSAGE',
//           payload: {
//             id: crypto.randomUUID(),
//             message: reason || 'Ticket marked as inactive due to 2-minute inactivity',
//             timestamp: new Date().toISOString(),
//             is_system: true
//           }
//         });
//       });

//       socketInstance.on('connect_error', (err) => {
//         console.error('Socket connection error:', err.message);
//         if (reconnectAttemptsRef.current >= 5) {
//           setError('Unable to connect to chat. Please refresh the page.');
//           return;
//         }
//         setError('Failed to connect to chat. Retrying...');
//         reconnectAttemptsRef.current += 1;
//         const delay = Math.min(1000 * 2 ** reconnectAttemptsRef.current, 30000);
//         setTimeout(initializeSocket, delay);
//       });

//       if (!chatState.messages.length) {
//         await fetchMessages();
//       }
//     } catch (err) {
//       console.error('Socket initialization error:', err);
//       setError('Unable to connect. Please try again.');
//     } finally {
//       setLoading(false);
//     }
//   }, [ticketId, readOnly, fetchMessages, throttledDispatch]);

//   // Socket initialization effect
//   useEffect(() => {
//     console.log('Socket initialization useEffect triggered', { ticketId, readOnly });
//     initializeSocket();
//     return () => {
//       if (socketRef.current) {
//         socketRef.current.emit('leave', { ticket_id: ticketId });
//         socketRef.current.off('message');
//         socketRef.current.off('ticket_closed');
//         socketRef.current.off('ticket_reopened');
//         socketRef.current.off('ticket_inactive');
//         socketRef.current.off('connect_error');
//         socketRef.current.off('connect');
//         socketRef.current = null;
//       }
//       if (inactivityTimerRef.current) {
//         clearTimeout(inactivityTimerRef.current);
//       }
//     };
//   }, [initializeSocket]);

//   // Polling for messages and ticket status
//   useEffect(() => {
//     console.log('Polling useEffect triggered', { ticketId, readOnly, socketConnected: socketRef.current?.connected });
//     if (!readOnly && ticketId && ticketId !== 'null' && !socketRef.current?.connected) {
//       const pollingInterval = setInterval(() => {
//         if (Date.now() - lastFetchTimeRef.current > 60000) {
//           fetchTicketStatus();
//           fetchMessages();
//           lastFetchTimeRef.current = Date.now();
//         }
//       }, 60000);
//       return () => clearInterval(pollingInterval);
//     }
//   }, [ticketId, readOnly, fetchMessages, fetchTicketStatus]);

//   // Inactivity timeout
//   useEffect(() => {
//     console.log('Inactivity timeout useEffect triggered', { ticketId, readOnly, ticketStatus: chatState.ticketStatus });
//     if (inactivityTimeout && !readOnly && ticketId && chatState.ticketStatus !== 'closed' && chatState.ticketStatus !== 'pending_inactive') {
//       const resetTimer = () => {
//         if (inactivityTimerRef.current) {
//           clearTimeout(inactivityTimerRef.current);
//         }
//         inactivityTimerRef.current = setTimeout(() => {
//           if (socketRef.current && chatState.ticketStatus !== 'closed' && chatState.ticketStatus !== 'pending_inactive') {
//             socketRef.current.emit('inactivity_timeout', { ticket_id: ticketId });
//             throttledDispatch({ type: 'SET_TICKET_STATUS', payload: 'pending_inactive' });
//           }
//         }, inactivityTimeout);
//       };

//       resetTimer();

//       const debouncedActivity = debounce(resetTimer, 1000);
//       window.addEventListener('keydown', debouncedActivity);
//       window.addEventListener('mousemove', debouncedActivity);

//       return () => {
//         if (inactivityTimerRef.current) {
//           clearTimeout(inactivityTimerRef.current);
//         }
//         window.removeEventListener('keydown', debouncedActivity);
//         window.removeEventListener('mousemove', debouncedActivity);
//         debouncedActivity.cancel();
//       };
//     }
//   }, [inactivityTimeout, ticketId, readOnly, chatState.ticketStatus, throttledDispatch]);

//   // Scroll to bottom on message update
//   useEffect(() => {
//     console.log('Scroll to bottom useEffect triggered', { messageCount: chatState.messages.length, loading });
//     if (chatState.messages.length && scrollContainerRef.current && !loading) {
//       messagesEndRef.current?.scrollIntoView({ behavior: 'auto' });
//     }
//   }, [loading, chatState.messages.length]);

//   // Scroll handling
//   useEffect(() => {
//     console.log('Scroll handling useEffect triggered', { messageCount: chatState.messages.length });
//     if (!scrollContainerRef.current) return;

//     const scrollContainer = scrollContainerRef.current;
//     const isNearBottom = () => {
//       const threshold = 100;
//       return scrollContainer.scrollHeight - scrollContainer.scrollTop - scrollContainer.clientHeight < threshold;
//     };

//     const handleScroll = debounce(() => {
//       setShowScrollButton(!isNearBottom());
//     }, 200);

//     if (isNearBottom() || lastSentMessageRef.current) {
//       messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
//       setShowScrollButton(false);
//       lastSentMessageRef.current = null;
//     } else {
//       setShowScrollButton(!isNearBottom());
//     }

//     scrollContainer.addEventListener('scroll', handleScroll);
//     return () => {
//       scrollContainer.removeEventListener('scroll', handleScroll);
//       handleScroll.cancel();
//     };
//   }, [chatState.messages.length]);

//   // Send message handler
//   const handleSend = useCallback(async () => {
//     if (!message.trim() || !socketRef.current || chatState.ticketStatus === 'closed' || isSending) return;
//     try {
//       setIsSending(true);
//       socketRef.current.emit('message', {
//         ticket_id: ticketId,
//         sender_id: user.id,
//         sender_name: `${user.firstName} ${user.lastName}`,
//         message: message.trim(),
//         timestamp: new Date().toISOString()
//       });
//       setMessage('');
//       lastSentMessageRef.current = true;
//       if (inactivityTimerRef.current) {
//         clearTimeout(inactivityTimerRef.current);
//         inactivityTimerRef.current = setTimeout(() => {
//           if (socketRef.current && chatState.ticketStatus !== 'closed' && chatState.ticketStatus !== 'pending_inactive') {
//             socketRef.current.emit('inactivity_timeout', { ticket_id: ticketId });
//             throttledDispatch({ type: 'SET_TICKET_STATUS', payload: 'pending_inactive' });
//           }
//         }, inactivityTimeout);
//       }
//     } catch (err) {
//       setError('Failed to send message.');
//     } finally {
//       setIsSending(false);
//     }
//   }, [message, ticketId, user, inactivityTimeout, chatState.ticketStatus, isSending, throttledDispatch]);

//   // Key press handler
//   const handleKeyPress = useCallback((e) => {
//     if (e.key === 'Enter' && !e.shiftKey) {
//       e.preventDefault();
//       handleSend();
//     }
//   }, [handleSend]);

//   const scrollToBottom = useCallback(() => {
//     messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
//     setShowScrollButton(false);
//   }, []);

//   const isMessageInputDisabled = readOnly || chatState.ticketStatus === 'closed' || isSending;

//   // Memoized message grouping
//   const groupedMessages = useMemo(() => {
//     return chatState.messages.reduce((acc, message) => {
//       const date = new Intl.DateTimeFormat('en-US', {
//         month: 'long',
//         day: 'numeric',
//         year: 'numeric'
//       }).format(new Date(message.timestamp));
//       if (!acc[date]) {
//         acc[date] = [];
//       }
//       acc[date].push(message);
//       return acc;
//     }, {});
//   }, [chatState.messages]);

//   if (loading) {
//     return (
//       <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
//         <CircularProgress />
//       </Box>
//     );
//   }

//   if (error) {
//     return (
//       <Box sx={{ p: 2 }}>
//         <Alert severity="error">{error}</Alert>
//       </Box>
//     );
//   }

//   return (
//     <Box sx={{
//       display: 'flex',
//       flexDirection: 'column',
//       width: '100%',
//       height: '100%',
//       bgcolor: '#f5f6f5',
//       borderRadius: 2,
//       overflowX: 'auto',
//     }}>
//       <Box
//         ref={scrollContainerRef}
//         sx={{
//           flex: 1,
//           p: 2,
//           overflow: 'auto',
//           display: 'flex',
//           flexDirection: 'column',
//           gap: 2,
//           minHeight: '200px',
//           '&::-webkit-scrollbar': {
//             width: '10px'
//           },
//           '&::-webkit-scrollbar-track': {
//             bgcolor: '#e5e7eb'
//           },
//           '&::-webkit-scrollbar-thumb': {
//             bgcolor: '#6b7280',
//             borderRadius: '5px',
//             '&:hover': { bgcolor: '#4b5563' }
//           },
//           scrollbarWidth: 'thin',
//           scrollbarColor: '#6b7280 #e5e7eb'
//         }}
//       >
//         {Object.entries(groupedMessages).map(([date, dateMessages]) => (
//           <React.Fragment key={date}>
//             <Box sx={{
//               display: 'flex',
//               justifyContent: 'center',
//               my: 1
//             }}>
//               <Paper sx={{
//                 px: 2,
//                 py: 0.5,
//                 borderRadius: 10,
//                 bgcolor: '#e0f2fe'
//               }}>
//                 <Typography variant="caption" fontWeight="medium">{date}</Typography>
//               </Paper>
//             </Box>
//             {dateMessages.map((msg, index) => (
//               <Box
//                 key={msg.id || index}
//                 sx={{
//                   display: 'flex',
//                   flexDirection: 'column',
//                   alignItems: msg.sender_id === user.id ? 'flex-end' : 'flex-start',
//                   mb: 2
//                 }}
//               >
//                 {msg.is_system ? (
//                   <Typography variant="caption" sx={{
//                     textAlign: 'center',
//                     color: 'text.secondary',
//                     my: 1,
//                     bgcolor: '#f0f0f0',
//                     px: 2,
//                     py: 1,
//                     borderRadius: 10
//                   }}>
//                     {msg.message}
//                   </Typography>
//                 ) : (
//                   <Box sx={{
//                     display: 'flex',
//                     flexDirection: msg.sender_id === user.id ? 'row-reverse' : 'row',
//                     alignItems: 'flex-start',
//                     gap: 1,
//                     maxWidth: '70%'
//                   }}>
//                     <Avatar sx={{
//                       width: 36,
//                       height: 36,
//                       bgcolor: msg.sender_id === user.id ? '#10b981' : '#6b7280'
//                     }}>
//                       {msg.sender_name?.charAt(0).toUpperCase() || 'U'}
//                     </Avatar>
//                     <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
//                       <Typography
//                         variant="caption"
//                         sx={{
//                           color: 'text.secondary',
//                           fontWeight: 'medium',
//                           ml: msg.sender_id === user.id ? 0 : 1,
//                           mr: msg.sender_id === user.id ? 1 : 0
//                         }}
//                       >
//                         {msg.sender_name}
//                       </Typography>
//                       <Paper
//                         sx={{
//                           p: 1.5,
//                           borderRadius: msg.sender_id === user.id ?
//                             '16px 16px 4px 16px' : '16px 16px 16px 4px',
//                           bgcolor: msg.sender_id === user.id ? '#d1fae5' : 'white'
//                         }}
//                       >
//                         <Typography variant="body2">{msg.message}</Typography>
//                         <Typography
//                           variant="caption"
//                           sx={{
//                             display: 'block',
//                             textAlign: 'right',
//                             mt: 0.5,
//                             color: 'text.secondary',
//                             fontSize: '0.65rem'
//                           }}
//                         >
//                           {new Intl.DateTimeFormat('en-US', {
//                             hour: 'numeric',
//                             minute: '2-digit',
//                             hour12: true
//                           }).format(new Date(msg.timestamp))}
//                         </Typography>
//                       </Paper>
//                     </Box>
//                   </Box>
//                 )}
//               </Box>
//             ))}
//           </React.Fragment>
//         ))}
//         <div ref={messagesEndRef} />
//       </Box>
//       {showScrollButton && (
//         <MuiIconButton
//           onClick={scrollToBottom}
//           sx={{
//             position: 'absolute',
//             bottom: readOnly ? 16 : 80,
//             right: 16,
//             bgcolor: '#10b981',
//             color: 'white',
//             '&:hover': { bgcolor: '#059669' },
//             boxShadow: 2
//           }}
//           aria-label="Scroll to bottom"
//         >
//           <ArrowDownwardIcon />
//         </MuiIconButton>
//       )}
//       {!readOnly && (
//         <Box sx={{
//           p: 2,
//           bgcolor: '#f9fafb',
//           borderTop: '1px solid #e5e7eb'
//         }}>
//           {chatState.ticketStatus === 'closed' && (
//             <Alert severity="info" sx={{ mb: 1, borderRadius: 2 }}>
//               This ticket is closed. No new messages can be sent.
//             </Alert>
//           )}
//           <Box sx={{
//             display: 'flex',
//             gap: 1,
//             alignItems: 'center',
//             bgcolor: 'white',
//             p: 1,
//             borderRadius: 2
//           }}>
//             <TextField
//               fullWidth
//               size="small"
//               placeholder={chatState.ticketStatus === 'closed' ? "Ticket closed, cannot send messages" : "Enter your message..."}
//               value={message}
//               onChange={(e) => setMessage(e.target.value)}
//               onKeyPress={handleKeyPress}
//               disabled={isMessageInputDisabled}
//               sx={{
//                 '& .MuiOutlinedInput-root': {
//                   borderRadius: 2,
//                   '& fieldset': { border: 'none' },
//                   '&.Mui-disabled': { bgcolor: '#f5f5f5' }
//                 }
//               }}
//               aria-label="Message input"
//             />
//             <IconButton
//               onClick={handleSend}
//               disabled={isMessageInputDisabled || !message.trim()}
//               sx={{
//                 bgcolor: isMessageInputDisabled ? '#e5e7eb' : '#10b981',
//                 color: isMessageInputDisabled ? '#9ca3af' : 'white',
//                 '&:hover': { bgcolor: isMessageInputDisabled ? '#e5e7eb' : '#059669' },
//                 borderRadius: 2
//               }}
//               aria-label="Send message"
//             >
//               {isSending ? <CircularProgress size={20} color="inherit" /> : <SendIcon fontSize="small" />}
//             </IconButton>
//           </Box>
//         </Box>
//       )}
//     </Box>
//   );
// };

// // Custom comparison for React.memo
// const arePropsEqual = (prevProps, nextProps) => {
//   return (
//     prevProps.ticketId === nextProps.ticketId &&
//     prevProps.readOnly === nextProps.readOnly &&
//     prevProps.inactivityTimeout === nextProps.inactivityTimeout &&
//     prevProps.initialMessages === nextProps.initialMessages
//   );
// };

// // Wrap ChatWindow with ErrorBoundary
// const WrappedChatWindow = (props) => (
//   <ErrorBoundary>
//     <ChatWindow {...props} />
//   </ErrorBoundary>
// );

// export default React.memo(WrappedChatWindow, arePropsEqual);



import React, { useState, useEffect, useRef, useReducer, useCallback, useMemo } from 'react';
import {
  Box, TextField, IconButton, Paper, Typography, Avatar,
  CircularProgress, Alert, IconButton as MuiIconButton
} from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import useStore from '../store/useStore';
import { getSocket } from './socket';
import { useNavigate } from 'react-router-dom';
import { debounce, throttle } from 'lodash';

const API_URL = (() => {
  try {
    if (typeof process !== 'undefined' && process.env) {
      return process.env.REACT_APP_API_URL || 'http://localhost:5000';
    }
    if (typeof import.meta !== 'undefined' && import.meta.env) {
      return import.meta.env.VITE_API_URL || 'http://localhost:5000';
    }
    return 'http://localhost:5000';
  } catch (e) {
    console.warn('Error accessing environment variables:', e);
    return 'http://localhost:5000';
  }
})();

// Reducer for messages and ticketStatus
const chatReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_MESSAGE':
      if (state.messages.some((msg) => msg.id === action.payload.id)) {
        return state; // Prevent duplicates
      }
      return { ...state, messages: [...state.messages, action.payload] };
    case 'SET_MESSAGES':
      const newMessages = action.payload.filter(
        (msg) => !state.messages.some((existing) => existing.id === msg.id)
      );
      return { ...state, messages: [...state.messages, ...newMessages] };
    case 'SET_TICKET_STATUS':
      return { ...state, ticketStatus: action.payload };
    default:
      return state;
  }
};

const ChatWindow = ({ ticketId, readOnly = false, initialMessages = [], inactivityTimeout = 120000 }) => {
  const [message, setMessage] = useState('');
  const [chatState, dispatch] = useReducer(chatReducer, {
    messages: initialMessages,
    ticketStatus: null
  });
  const [loading, setLoading] = useState(Boolean(ticketId && !initialMessages.length));
  const [error, setError] = useState('');
  const [showScrollButton, setShowScrollButton] = useState(false);
  const messagesEndRef = useRef(null);
  const scrollContainerRef = useRef(null);
  const socketRef = useRef(null);
  const user = useStore((state) => state.user);
  const inactivityTimerRef = useRef(null);
  const lastSentMessageRef = useRef(null);
  const reconnectAttemptsRef = useRef(0);
  const navigate = useNavigate();

  // Render counter for debugging
  const renderCount = useRef(0);
  useEffect(() => {
    renderCount.current += 1;
    console.log(`Render #${renderCount.current} for ChatWindow, ticketId: ${ticketId}`);
  });

  // Clear error after 5 seconds
  useEffect(() => {
    if (error) {
      const timer = setTimeout(() => setError(''), 5000);
      return () => clearTimeout(timer);
    }
  }, [error]);

  // Throttled dispatch to reduce rapid state updates
  const throttledDispatch = useCallback(
    throttle((action) => dispatch(action), 100),
    []
  );

  // Fetch messages
  const fetchMessages = useCallback(async () => {
    if (!ticketId) return;
    const token = localStorage.getItem('token');
    if (!token) {
      setError('Please log in to view messages.');
      navigate('/');
      return;
    }
    try {
      setLoading(true);
      const response = await fetch(`${API_URL}/api/chats/${ticketId}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      if (!response.ok) {
        throw new Error('Failed to fetch messages');
      }
      const data = await response.json();
      throttledDispatch({ type: 'SET_MESSAGES', payload: data });
    } catch (error) {
      console.error('Fetch Messages Error:', error);
      setError('Unable to load messages.');
      if (error.message.includes('token') || error.message.includes('Unauthorized')) {
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        navigate('/');
      }
    } finally {
      setLoading(false);
    }
  }, [ticketId, navigate, throttledDispatch]);

  // Fetch ticket status
  const fetchTicketStatus = useCallback(async () => {
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        throw new Error('No authentication token found');
      }
      const response = await fetch(`${API_URL}/api/tickets/${ticketId}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      if (!response.ok) {
        throw new Error('Failed to fetch ticket status');
      }
      const data = await response.json();
      throttledDispatch({ type: 'SET_TICKET_STATUS', payload: data.status });
    } catch (error) {
      console.error('Error fetching ticket status:', error);
      setError('Unable to load ticket status.');
      if (error.message.includes('token') || error.message.includes('Unauthorized')) {
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        navigate('/');
      }
    }
  }, [ticketId, navigate, throttledDispatch]);

  // Initialize socket with reconnection logic
  const initializeSocket = useCallback(async () => {
    setLoading(true);
    try {
      const socketInstance = await getSocket();
      if (!socketInstance) {
        throw new Error('Socket initialization failed.');
      }

      socketRef.current = socketInstance;
      socketInstance.emit('join', { ticket_id: ticketId });

      socketInstance.on('connect', () => {
        console.log('WebSocket connected for ticket:', ticketId);
        setError('');
        reconnectAttemptsRef.current = 0;
      });

      socketInstance.on('message', (newMessage) => {
        if (newMessage.ticket_id === String(ticketId)) {
          throttledDispatch({
            type: 'ADD_MESSAGE',
            payload: {
              id: newMessage.id || crypto.randomUUID(),
              message: newMessage.message,
              sender_id: newMessage.sender_id,
              sender_name: newMessage.sender_name || 'Unknown',
              timestamp: newMessage.timestamp || new Date().toISOString(),
              is_system: false
            }
          });
        }
      });

      socketInstance.on('ticket_closed', ({ ticket_id, reason, reassigned_to, status }) => {
        if (ticket_id !== String(ticketId)) return;
        throttledDispatch({ type: 'SET_TICKET_STATUS', payload: status || 'closed' });
        throttledDispatch({
          type: 'ADD_MESSAGE',
          payload: {
            id: crypto.randomUUID(),
            message: `Ticket ${status === 'assigned' ? 'reassigned' : 'closed'}. Reason: ${reason}${reassigned_to ? `. Reassigned to member ID ${reassigned_to}` : ''}`,
            timestamp: new Date().toISOString(),
            is_system: true
          }
        });
      });

      socketInstance.on('ticket_reopened', ({ ticket_id }) => {
        if (ticket_id !== String(ticketId)) return;
        throttledDispatch({ type: 'SET_TICKET_STATUS', payload: 'assigned' });
        throttledDispatch({
          type: 'ADD_MESSAGE',
          payload: {
            id: crypto.randomUUID(),
            message: 'Ticket has been reopened',
            timestamp: new Date().toISOString(),
            is_system: true
          }
        });
      });

      socketInstance.on('ticket_inactive', ({ ticket_id, status, reason }) => {
        if (ticket_id !== String(ticketId)) return;
        throttledDispatch({ type: 'SET_TICKET_STATUS', payload: status || 'inactive' });
        throttledDispatch({
          type: 'ADD_MESSAGE',
          payload: {
            id: crypto.randomUUID(),
            message: reason || 'Ticket marked as inactive due to 2-minute inactivity',
            timestamp: new Date().toISOString(),
            is_system: true
          }
        });
      });

      socketInstance.on('connect_error', (err) => {
        console.error('Socket connection error:', err.message);
        setError('Failed to connect to chat. Retrying...');
        reconnectAttemptsRef.current += 1;
        const delay = Math.min(1000 * 2 ** reconnectAttemptsRef.current, 30000);
        setTimeout(initializeSocket, delay);
      });

      if (!chatState.messages.length) {
        await fetchMessages();
      }
    } catch (err) {
      console.error('Socket initialization error:', err);
      setError('Unable to connect. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [ticketId, fetchMessages, throttledDispatch]);

  // Socket initialization effect
  useEffect(() => {
    if (readOnly || !ticketId || ticketId === 'null') {
      setLoading(false);
      return;
    }

    initializeSocket();

    return () => {
      if (socketRef.current) {
        socketRef.current.emit('leave', { ticket_id: ticketId });
        socketRef.current.off('message');
        socketRef.current.off('ticket_closed');
        socketRef.current.off('ticket_reopened');
        socketRef.current.off('ticket_inactive');
        socketRef.current.off('connect_error');
        socketRef.current.off('connect');
      }
      if (inactivityTimerRef.current) {
        clearTimeout(inactivityTimerRef.current);
      }
    };
  }, [initializeSocket, ticketId, readOnly]);

  // Ticket status polling
  useEffect(() => {
    if (!readOnly && ticketId && ticketId !== 'null') {
      fetchTicketStatus();
      const pollingInterval = setInterval(() => {
        if (chatState.ticketStatus !== 'closed' && !socketRef.current?.connected) {
          fetchTicketStatus();
        }
      }, 30000);
      return () => clearInterval(pollingInterval);
    }
  }, [fetchTicketStatus, ticketId, readOnly, chatState.ticketStatus]);

  // Fallback polling for messages
  useEffect(() => {
    if (!readOnly && ticketId && ticketId !== 'null' && !socketRef.current?.connected) {
      const lastMessageTime = chatState.messages.length
        ? new Date(chatState.messages[chatState.messages.length - 1].timestamp).getTime()
        : 0;
      const pollingInterval = setInterval(() => {
        if (Date.now() - lastMessageTime > 30000) {
          fetchMessages();
        }
      }, 30000);
      return () => clearInterval(pollingInterval);
    }
  }, [ticketId, readOnly, fetchMessages, chatState.messages]);

  // Inactivity timeout
  useEffect(() => {
    if (inactivityTimeout && !readOnly && ticketId && chatState.ticketStatus !== 'closed') {
      const resetTimer = () => {
        if (inactivityTimerRef.current) {
          clearTimeout(inactivityTimerRef.current);
        }
        inactivityTimerRef.current = setTimeout(() => {
          if (socketRef.current) {
            socketRef.current.emit('inactivity_timeout', { ticket_id: ticketId });
            throttledDispatch({ type: 'SET_TICKET_STATUS', payload: 'pending_inactive' });
          }
        }, inactivityTimeout);
      };

      resetTimer();

      const debouncedActivity = debounce(resetTimer, 500);
      window.addEventListener('keydown', debouncedActivity);
      window.addEventListener('mousemove', debouncedActivity);

      return () => {
        if (inactivityTimerRef.current) {
          clearTimeout(inactivityTimerRef.current);
        }
        window.removeEventListener('keydown', debouncedActivity);
        window.removeEventListener('mousemove', debouncedActivity);
        debouncedActivity.cancel();
      };
    }
  }, [inactivityTimeout, ticketId, readOnly, chatState.ticketStatus, throttledDispatch]);

  // Scroll to bottom on message update
  useEffect(() => {
    if (chatState.messages.length && scrollContainerRef.current && !loading) {
      messagesEndRef.current?.scrollIntoView({ behavior: 'auto' });
    }
  }, [loading, chatState.messages]);

  // Scroll handling
  useEffect(() => {
    if (!scrollContainerRef.current) return;

    const scrollContainer = scrollContainerRef.current;
    const isNearBottom = () => {
      const threshold = 100;
      return scrollContainer.scrollHeight - scrollContainer.scrollTop - scrollContainer.clientHeight < threshold;
    };

    const handleScroll = debounce(() => {
      setShowScrollButton(!isNearBottom());
    }, 100);

    if (isNearBottom() || lastSentMessageRef.current) {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      lastSentMessageRef.current = null;
    }

    setShowScrollButton(!isNearBottom());
    scrollContainer.addEventListener('scroll', handleScroll);
    return () => {
      scrollContainer.removeEventListener('scroll', handleScroll);
      handleScroll.cancel();
    };
  }, [chatState.messages]);

  // Send message handler
  const handleSend = useCallback(async () => {
    if (!message.trim() || !socketRef.current || chatState.ticketStatus === 'closed') return;
    try {
      socketRef.current.emit('message', {
        ticket_id: ticketId,
        sender_id: user.id,
        sender_name: `${user.firstName} ${user.lastName}`,
        message: message.trim(),
        timestamp: new Date().toISOString()
      });
      setMessage('');
      lastSentMessageRef.current = true;
      if (inactivityTimerRef.current) {
        clearTimeout(inactivityTimerRef.current);
        inactivityTimerRef.current = setTimeout(() => {
          socketRef.current?.emit('inactivity_timeout', { ticket_id: ticketId });
          throttledDispatch({ type: 'SET_TICKET_STATUS', payload: 'pending_inactive' });
        }, inactivityTimeout);
      }
    } catch (err) {
      setError('Failed to send message.');
    }
  }, [message, ticketId, user, inactivityTimeout, chatState.ticketStatus, throttledDispatch]);

  // Key press handler
  const handleKeyPress = useCallback((e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  }, [handleSend]);

  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    setShowScrollButton(false);
  }, []);

  const isMessageInputDisabled = readOnly || chatState.ticketStatus === 'closed';

  // Memoized message grouping
  const groupedMessages = useMemo(() => {
    return chatState.messages.reduce((acc, message) => {
      const date = new Intl.DateTimeFormat('en-US', {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      }).format(new Date(message.timestamp));
      if (!acc[date]) {
        acc[date] = [];
      }
      acc[date].push(message);
      return acc;
    }, {});
  }, [chatState.messages]);

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box sx={{ p: 2 }}>
        <Alert severity="error">{error}</Alert>
      </Box>
    );
  }

  return (
    <Box sx={{
      display: 'flex',
      flexDirection: 'column',
      width: '100%',
      height: '100%',
      bgcolor: '#f5f6f5',
      borderRadius: 2,
      overflowX: 'auto',
    }}>
      <Box
        ref={scrollContainerRef}
        sx={{
          flex: 1,
          p: 2,
          overflow: 'auto',
          display: 'flex',
          flexDirection: 'column',
          gap: 2,
          minHeight: '200px',
          '&::-webkit-scrollbar': {
            width: '10px'
          },
          '&::-webkit-scrollbar-track': {
            bgcolor: '#e5e7eb'
          },
          '&::-webkit-scrollbar-thumb': {
            bgcolor: '#6b7280',
            borderRadius: '5px',
            '&:hover': { bgcolor: '#4b5563' }
          },
          scrollbarWidth: 'thin',
          scrollbarColor: '#6b7280 #e5e7eb'
        }}
      >
        {Object.entries(groupedMessages).map(([date, dateMessages]) => (
          <React.Fragment key={date}>
            <Box sx={{
              display: 'flex',
              justifyContent: 'center',
              my: 1
            }}>
              <Paper sx={{
                px: 2,
                py: 0.5,
                borderRadius: 10,
                bgcolor: '#e0f2fe'
              }}>
                <Typography variant="caption" fontWeight="medium">{date}</Typography>
              </Paper>
            </Box>
            {dateMessages.map((msg, index) => (
              <Box
                key={msg.id || index}
                sx={{
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: msg.sender_id === user.id ? 'flex-end' : 'flex-start',
                  mb: 2
                }}
              >
                {msg.is_system ? (
                  <Typography variant="caption" sx={{
                    textAlign: 'center',
                    color: 'text.secondary',
                    my: 1,
                    bgcolor: '#f0f0f0',
                    px: 2,
                    py: 1,
                    borderRadius: 10
                  }}>
                    {msg.message}
                  </Typography>
                ) : (
                  <Box sx={{
                    display: 'flex',
                    flexDirection: msg.sender_id === user.id ? 'row-reverse' : 'row',
                    alignItems: 'flex-start',
                    gap: 1,
                    maxWidth: '70%'
                  }}>
                    <Avatar sx={{
                      width: 36,
                      height: 36,
                      bgcolor: msg.sender_id === user.id ? '#10b981' : '#6b7280'
                    }}>
                      {msg.sender_name?.charAt(0).toUpperCase() || 'U'}
                    </Avatar>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
                      <Typography
                        variant="caption"
                        sx={{
                          color: 'text.secondary',
                          fontWeight: 'medium',
                          ml: msg.sender_id === user.id ? 0 : 1,
                          mr: msg.sender_id === user.id ? 1 : 0
                        }}
                      >
                        {msg.sender_name}
                      </Typography>
                      <Paper
                        sx={{
                          p: 1.5,
                          borderRadius: msg.sender_id === user.id ?
                            '16px 16px 4px 16px' : '16px 16px 16px 4px',
                          bgcolor: msg.sender_id === user.id ? '#d1fae5' : 'white'
                        }}
                      >
                        <Typography variant="body2">{msg.message}</Typography>
                        <Typography
                          variant="caption"
                          sx={{
                            display: 'block',
                            textAlign: 'right',
                            mt: 0.5,
                            color: 'text.secondary',
                            fontSize: '0.65rem'
                          }}
                        >
                          {new Intl.DateTimeFormat('en-US', {
                            hour: 'numeric',
                            minute: '2-digit',
                            hour12: true
                          }).format(new Date(msg.timestamp))}
                        </Typography>
                      </Paper>
                    </Box>
                  </Box>
                )}
              </Box>
            ))}
          </React.Fragment>
        ))}
        <div ref={messagesEndRef} />
      </Box>
      {showScrollButton && (
        <MuiIconButton
          onClick={scrollToBottom}
          sx={{
            position: 'absolute',
            bottom: readOnly ? 16 : 80,
            right: 16,
            bgcolor: '#10b981',
            color: 'white',
            '&:hover': { bgcolor: '#059669' },
            boxShadow: 2
          }}
          aria-label="Scroll to bottom"
        >
          <ArrowDownwardIcon />
        </MuiIconButton>
      )}
      {!readOnly && (
        <Box sx={{
          p: 2,
          bgcolor: '#f9fafb',
          borderTop: '1px solid #e5e7eb'
        }}>
          {chatState.ticketStatus === 'closed' && (
            <Alert severity="info" sx={{ mb: 1, borderRadius: 2 }}>
              This ticket is closed. No new messages can be sent.
            </Alert>
          )}
          <Box sx={{
            display: 'flex',
            gap: 1,
            alignItems: 'center',
            bgcolor: 'white',
            p: 1,
            borderRadius: 2
          }}>
            <TextField
              fullWidth
              size="small"
              placeholder={chatState.ticketStatus === 'closed' ? "Ticket is closed" : "Type a message..."}
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              onKeyPress={handleKeyPress}
              disabled={isMessageInputDisabled}
              sx={{
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2,
                  '& fieldset': { border: 'none' }
                }
              }}
              aria-label="Type a message"
            />
            <IconButton
              onClick={handleSend}
              disabled={isMessageInputDisabled || !message.trim()}
              sx={{
                bgcolor: isMessageInputDisabled ? '#e5e7eb' : '#10b981',
                color: isMessageInputDisabled ? '#9ca3af' : 'white',
                '&:hover': { bgcolor: isMessageInputDisabled ? '#e5e7eb' : '#059669' },
                borderRadius: 1
              }}
              aria-label="Send message"
            >
              <SendIcon fontSize="small" />
            </IconButton>
          </Box>
        </Box>
      )}
    </Box>
  );
};

export default React.memo(ChatWindow);